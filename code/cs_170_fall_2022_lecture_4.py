# -*- coding: utf-8 -*-
"""CS 170 Fall 2022, Lecture 4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NFB1tO0ytbRVIg0ZKqHehSJlyvvR7aws
"""

# AUTHOR: Jelani Nelson
 # VERSION: 1.0, 09/13/2022
 # BSD 3-Clause

# FFT
import math
import numpy # just for complex conjugate method (numpy.conj(a+ib) is a-ib)

# return smallest power of 2 that is >= n
def hyperceil(n):
  if n == 0:
    return 1
  j = 0
  m = n
  while m > 0:
    j += 1
    m >>= 1
  if 1<<(j-1) == n:
    return n
  else:
    return 1<<j

def fft(a):
  # only works if len(a) is a power of 2
  assert (len(a) == hyperceil(len(a)))
  n = len(a)
  if n == 1:
    return a[:]
  aeven_transform = fft(a[::2]) # even indexed coeffs
  aodd_transform = fft(a[1::2]) # odd indexed coeffs
  w = complex(math.cos(2*math.pi/n), math.sin(2*math.pi/n))
  cur = 1
  ans = []
  for i in range(n):
    ans.append(aeven_transform[i%(n//2)] + cur*aodd_transform[i%(n//2)])
    cur *= w
  return ans

# FAST POLYNOMIAL MULTIPLICATION USING FFT
# a are coeffs of A(x), and b of B(x)
def fast_poly_mult(a, b):
  n = max(len(a), len(b))
  N = hyperceil(2*n-1)
  apad = a + [0]*(N-len(a))
  bpad = b + [0]*(N-len(b))

  ah = fft(apad)
  bh = fft(bpad)
  ch = [a*b for a,b in zip(ah, bh)]
  
  # can show F^{-1} = (1/N) F~, where ~ is entry-wise complex conjugate
  # then F~ * y = (F * (y~))~ (a fact about complex matrix-vec mult)
  z = fft([numpy.conj(x) for x in ch])
  c = [x.real/N for x in z]

  return c[:len(a)+len(b)-1]

# FAST CROSS-CORRELATION USING FAST POLY MULT
def cross_correlation(x, y):
  assert (len(x) <= len(y))
  return fast_poly_mult(x[::-1], y)[len(x)-1:len(y)]

print(fast_poly_mult([1, 1], [1, 1]))
print(cross_correlation([1, 3], [1, 2, 1]))

